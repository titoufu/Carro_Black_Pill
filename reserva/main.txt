#include "main.h"
#include <cstdlib>
#include "motor_config.hpp"
#include "motor.hpp"

/* --- NOVO: TIM1 para PWM em PB15 (TIM1_CH3N) --- */
TIM_HandleTypeDef htim1;

static void MX_TIM1_Init(void);

/* ---------- Prototypes ---------- */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_TIM3_Init(void); // ENB = PB4 (TIM3_CH1)
static void MX_TIM4_Init(void); // ENA = PB9 (TIM4_CH4)
void Error_Handler(void);

/* ---------- Handles (usados pela config) ---------- */
TIM_HandleTypeDef htim3; // APB1
TIM_HandleTypeDef htim4; // APB1

/* ---------- Objetos Motor (8 parâmetros, tudo via config) ---------- */
Motor motorA(
    MOTOR_A_TIMER_HANDLE, MOTOR_A_CHANNEL,
    MOTOR_A_IN1_PORT, MOTOR_A_IN1_PIN,
    MOTOR_A_IN2_PORT, MOTOR_A_IN2_PIN,
    MOTOR_PWM_MAX, MOTOR_A_INVERT);
Motor motorB(
    MOTOR_B_TIMER_HANDLE, MOTOR_B_CHANNEL,
    MOTOR_B_IN1_PORT, MOTOR_B_IN1_PIN,
    MOTOR_B_IN2_PORT, MOTOR_B_IN2_PIN,
    MOTOR_PWM_MAX, MOTOR_B_INVERT);

/* ---------- PWM de software no LED PC13 (ativo-baixo) ---------- */
/* Gera ~100 Hz durante 'duration_ms', com duty 0..100 (%) */
static void led_softpwm_pc13(uint8_t duty_percent, uint16_t duration_ms)
{
  if (duty_percent > 100)
    duty_percent = 100;
  const uint16_t period_ms = 10; // ~100 Hz
  const uint16_t cycles = duration_ms / period_ms;
  const uint16_t on_ms = (uint16_t)((duty_percent * period_ms) / 100U);
  for (uint16_t i = 0; i < cycles; ++i)
  {
    // LED ON (ativo-baixo) pelo tempo "on_ms"
    if (on_ms > 0)
    {
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
      HAL_Delay(on_ms);
    }
    // LED OFF no restante do período
    if (on_ms < period_ms)
    {
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
      HAL_Delay(period_ms - on_ms);
    }
  }
}

/* ---------- Teste: rampa de PWM do Motor A + LED com mesmo duty ---------- */
static void test_motorA_pwm_ramp(void)
{
  // Frente
  motorA.setDirection(Motor::Direction::Forward);
  for (int d = 0; d <= 100; d += 10)
  {
    motorA.setSpeed((uint8_t)d);
    led_softpwm_pc13((uint8_t)d, 300); // 300 ms em 100 Hz
  }
  for (int d = 100; d >= 0; d -= 10)
  {
    motorA.setSpeed((uint8_t)d);
    led_softpwm_pc13((uint8_t)d, 200);
  }

  motorA.brake();
  led_softpwm_pc13(0, 400);

  // Ré
  motorA.setDirection(Motor::Direction::Backward);
  for (int d = 0; d <= 100; d += 10)
  {
    motorA.setSpeed((uint8_t)d);
    led_softpwm_pc13((uint8_t)d, 300);
  }
  for (int d = 100; d >= 0; d -= 10)
  {
    motorA.setSpeed((uint8_t)d);
    led_softpwm_pc13((uint8_t)d, 200);
  }

  motorA.coast();
  led_softpwm_pc13(0, 600);
}
static inline void pb15_pwm_set_percent(uint8_t duty)
{
  if (duty > 100)
    duty = 100;
  uint32_t arr = __HAL_TIM_GET_AUTORELOAD(&htim1);
  uint32_t ccr = (uint32_t)(duty * (arr + 1)) / 100U;
  __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_3, ccr);
}

static void pb15_pwm_ramp_test(void)
{
  for (int d = 0; d <= 100; d += 10)
  {
    pb15_pwm_set_percent((uint8_t)d);
    HAL_Delay(200);
  }
  for (int d = 100; d >= 0; d -= 10)
  {
    pb15_pwm_set_percent((uint8_t)d);
    HAL_Delay(120);
  }
}
// rampa suave para o Motor A (frente -> freio -> ré -> parar)
static void motorA_pwm_ramp(void)
{
  // frente (comece em 30% para vencer inércia)
  motorA.setDirection(Motor::Direction::Forward);
  for (int d = 30; d <= 80; d += 10)
  {
    motorA.setSpeed(d);
    HAL_Delay(400);
  }
  for (int d = 80; d >= 0; d -= 20)
  {
    motorA.setSpeed(d);
    HAL_Delay(250);
  }

  motorA.brake();
  HAL_Delay(500);

  // ré
  motorA.setDirection(Motor::Direction::Backward);
  for (int d = 30; d <= 80; d += 10)
  {
    motorA.setSpeed(d);
    HAL_Delay(400);
  }
  for (int d = 80; d >= 0; d -= 20)
  {
    motorA.setSpeed(d);
    HAL_Delay(250);
  }

  motorA.coast();
  HAL_Delay(700);
}
// Limita um valor a [mn, mx]
static inline int clamp(int v, int mn, int mx)
{
  return (v < mn) ? mn : (v > mx) ? mx
                                  : v;
}

// Define ambos os motores com valores assinados (-100..+100)
// negativos = ré; positivos = frente
static void driveSigned(int leftPct, int rightPct)
{
  leftPct = clamp(leftPct, -100, 100);
  rightPct = clamp(rightPct, -100, 100);

  // Motor A = lado esquerdo, Motor B = lado direito (ajuste se preferir)
  if (leftPct >= 0)
    motorA.start(Motor::Direction::Forward, (uint8_t)leftPct);
  else
    motorA.start(Motor::Direction::Backward, (uint8_t)(-leftPct));

  if (rightPct >= 0)
    motorB.start(Motor::Direction::Forward, (uint8_t)rightPct);
  else
    motorB.start(Motor::Direction::Backward, (uint8_t)(-rightPct));
}

// Arcade drive: throttle (frente/ré) e steer (giro), todos em -100..+100
static void arcadeDrive(int throttle, int steer)
{
  throttle = clamp(throttle, -100, 100);
  steer = clamp(steer, -100, 100);

  int left = throttle + steer;
  int right = throttle - steer;
  left = clamp(left, -100, 100);
  right = clamp(right, -100, 100);
  driveSigned(left, right);
}

// Rampa simples (limita variação por passo)
struct Ramp
{
  int value = 0; // atual (-100..+100)
  int step = 4;  // máx delta por atualização
  int updateTowards(int target)
  {
    target = clamp(target, -100, 100);
    int d = target - value;
    if (d > step)
      d = step;
    if (d < -step)
      d = -step;
    value += d;
    return value;
  }
};

/* ============================ main ============================ */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();          // PC13, INs e ENs conforme motor_config.hpp
  MX_TIM3_Init();          // PB4 -> TIM3_CH1
  MX_TIM4_Init();          // PB9 -> TIM4_CH4
  MX_TIM1_Init();          // inicia PWM de hardware no PB15 (1 kHz)
  pb15_pwm_set_percent(0); // começa apagado

  // Inicia PWM (duty=0)
  motorA.begin();
  motorB.begin();
  motorA.coast();
  motorB.coast();

  // exemplo: anda pra frente e curva, suavizando com rampa
  Ramp rThrottle{0, 5}, rSteer{0, 7}; // passos diferentes p/ “feeling”

  int t = 0;
  while (1)
  {

    // faz um padrão simples: frente 60% por 2s, curva direita 40% por 2s, ré 40% por 2s...
    int tgtThrottle = (t < 2000) ? 60 : (t < 4000) ? 60
                                    : (t < 6000)   ? -40
                                                   : 0;
    int tgtSteer = (t < 2000) ? 0 : (t < 4000) ? 40
                                : (t < 6000)   ? 0
                                               : 0;

    int thr = rThrottle.updateTowards(tgtThrottle);
    int st = rSteer.updateTowards(tgtSteer);
    pb15_pwm_set_percent((uint8_t)std::abs(thr));

    arcadeDrive(thr, st);

    HAL_Delay(20);
    t += 20;
    if (t >= 8000)
      t = 0; // reinicia ciclo
  }
}

/* ================ Clock: HSI -> PLL @ 84 MHz (como combinamos) ================ */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 168;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType =
      RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; // 84 MHz
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;  // 42 MHz (timers APB1 = 84 MHz)
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;  // 42 MHz (ok p/ este projeto)
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/* ================ GPIO: tudo via motor_config.hpp (sem duplicar pinos aqui) ================ */ static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();

  /* LED PC13 (ativo-baixo; inicia apagado) */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
  GPIO_InitStruct.Pin = GPIO_PIN_13;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /* Direções dos motores (IN1..IN4) */
  HAL_GPIO_WritePin(MOTOR_A_IN1_PORT, MOTOR_A_IN1_PIN, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(MOTOR_A_IN2_PORT, MOTOR_A_IN2_PIN, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(MOTOR_B_IN1_PORT, MOTOR_B_IN1_PIN, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(MOTOR_B_IN2_PORT, MOTOR_B_IN2_PIN, GPIO_PIN_RESET);

  GPIO_InitStruct.Pin = MOTOR_A_IN1_PIN | MOTOR_A_IN2_PIN |
                        MOTOR_B_IN1_PIN | MOTOR_B_IN2_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* ENA (PB9) -> TIM4_CH4 (AF2) */
  GPIO_InitStruct.Pin = MOTOR_A_EN_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.Alternate = MOTOR_A_EN_AF;
  HAL_GPIO_Init(MOTOR_A_EN_PORT, &GPIO_InitStruct);

  /* ENB (PB4) -> TIM3_CH1 (AF2) */
  GPIO_InitStruct.Pin = MOTOR_B_EN_PIN;
  GPIO_InitStruct.Alternate = MOTOR_B_EN_AF;
  HAL_GPIO_Init(MOTOR_B_EN_PORT, &GPIO_InitStruct);

  /* (Opcional) PB15 -> TIM1_CH3N (AF1) para PWM de LED real */
  GPIO_InitStruct.Pin = GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

/* ================ TIM3: PWM CH1 (PB4) a 20 kHz ================ */
static void MX_TIM3_Init(void)
{
  __HAL_RCC_TIM3_CLK_ENABLE();

  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 0;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = MOTOR_PWM_MAX; // 4199 -> 20 kHz (TIMCLK=84 MHz)
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }

  TIM_OC_InitTypeDef sConfigOC = {0};
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;

  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
}

/* ================ TIM4: PWM CH4 (PB9) a 20 kHz ================ */
static void MX_TIM4_Init(void)
{
  __HAL_RCC_TIM4_CLK_ENABLE();

  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 0;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = MOTOR_PWM_MAX; // 4199 -> 20 kHz
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }

  TIM_OC_InitTypeDef sConfigOC = {0};
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;

  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
}
/* TIM1 -> PWM em PB15 (TIM1_CH3N). 1 kHz com PSC=83, ARR=999 */
static void MX_TIM1_Init(void)
{
  __HAL_RCC_TIM1_CLK_ENABLE();

  htim1.Instance = TIM1;
  htim1.Init.Prescaler = 83; // 84 MHz / (83+1) = 1 MHz
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = 999; // 1 MHz / (999+1) = 1 kHz
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }

  TIM_OC_InitTypeDef sConfigOC = {0};
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;                          // duty inicial 0%
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;   // polaridade do canal "normal"
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH; // polaridade do canal "N" (PB15)
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;

  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }

  /* TIM1 é “advanced timer”: habilitar MOE no BDTR */
  TIM_BreakDeadTimeConfigTypeDef bdtr = {0};
  bdtr.OffStateRunMode = TIM_OSSR_DISABLE;
  bdtr.OffStateIDLEMode = TIM_OSSI_DISABLE;
  bdtr.LockLevel = TIM_LOCKLEVEL_OFF;
  bdtr.DeadTime = 0;
  bdtr.BreakState = TIM_BREAK_DISABLE;
  bdtr.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  bdtr.AutomaticOutput = TIM_AUTOMATICOUTPUT_ENABLE; // seta MOE automaticamente
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &bdtr) != HAL_OK)
  {
    Error_Handler();
  }

  /* Como PB15 é CH3N (complementar), usar a API "N" */
  if (HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/* ================ Error handler ================ */
void Error_Handler(void)
{
  __disable_irq();
  while (1)
  {
  }
}
